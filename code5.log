theory ID_Base_formalization begin

// Function signature and definition of the equational theory E

functions: Get_Masterpkey/1, KGCpkey/2, KGCskey/2, Make_Masterskey/2,
           UserID/4, dec/2, enc/2, fst/1, pair/2, snd/1
equations:
    dec(enc(message, KGCpkey(Get_Masterpkey(Masterskey), User)),
        KGCskey(Masterskey, User))
  = message,
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2





rule (modulo E) Setup:
   [ Fr( ~Masterskey ) ]
  --[ OnlyOnce( ) ]->
   [
   !Make_Masterskey( ~Masterskey, 'KGC' ),
   Out( <Get_Masterpkey(~Masterskey), 'KGC'> )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Create_Id:
   [ Fr( ~ID ), !Make_Masterskey( Masterskey, 'KGC' ) ]
  --[
  Create_ID( $User,
             <Get_Masterpkey(Masterskey), KGCskey(Masterskey, $User)>
  )
  ]->
   [
   !UserID( Get_Masterpkey(Masterskey), KGCskey(Masterskey, $User), $User,
            ~ID
   )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Attacker_Get_Masterskey:
   [ !Make_Masterskey( Masterskey, 'KGC' ) ]
  --[ Oracle( 'MsterKey', 'KGC' ) ]->
   [ Out( Masterskey ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Attacker_Get_Usersey:
   [ !UserID( Masterpkey, Userskey, $User, ~ID ) ]
  --[ Oracle( 'UserKey', $User ) ]->
   [ Out( Userskey ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Attacker_make_message:
   [ Fr( m_ ) ] --> [ Out( <'MsterKey', 'KGC', m_> ), St_Oracle( m_ ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Sender_encrypt:
   [ Fr( ~m ), Fr( ~nonce ), !UserID( Masterpkey, Userskey, 'a', ~ID ) ]
  --[
  Send( 'UserKey', $User, enc(<'MsterKey', 'KGC', ~m>, Userskey) ),
  Secret( ~nonce ), Role( 'Sender' )
  ]->
   [
   Out( enc(<~nonce, 'b', ~m>, KGCpkey(Masterpkey, 'b')) ),
   St_Sender( Masterpkey, Userskey, ~ID, ~nonce ),
   St_ReceiveKey( ~m, Masterpkey )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Encrypt_Attacker:
   [
   !Make_Masterskey( ~Masterskey, 'KGC' ), In( <'MsterKey', 'KGC', m_> ),
   In( <'UserKey', $User, ~m> ), St_Oracle( m_ ), Fr( ~nonce )
   ]
  --[
  Send( 'MsterKey', 'KGC', enc(<'MsterKey', 'KGC', m_>, ~Masterskey) ),
  Secret( ~nonce ), Role( 'Oracle' ), Attacker_send_plain( m_ )
  ]->
   [
   Out( enc(<'MsterKey', 'KGC', m_>, ~Masterskey) ),
   St_ReceiveKey_Oracle_plain( m_, ~Masterskey )
   ]

  /* has exactly the trivial AC variant */

rule (modulo E) Receiver_message:
   [
   In( c ), !UserID( Masterpkey, Userskey, 'b', ~ID ),
   St_Sender( Masterpkey, Userskey, ~ID, ~nonce )
   ]
  --[ Run( 'b', 'a', fst(dec(c, Userskey)) ) ]->
   [
   Out( enc(fst(dec(c, Userskey)), KGCpkey(Masterpkey, 'a')) ),
   St_Receiver( Masterpkey, Userskey, ~ID, ~nonce )
   ]

  /*
  rule (modulo AC) Receiver_message:
     [
     In( c ), !UserID( Masterpkey, Userskey, 'b', ~ID ),
     St_Sender( Masterpkey, Userskey, ~ID, ~nonce )
     ]
    --[ Run( 'b', 'a', z ) ]->
     [
     Out( enc(z, KGCpkey(Masterpkey, 'a')) ),
     St_Receiver( Masterpkey, Userskey, ~ID, ~nonce )
     ]
    variants (modulo AC)
    1. Userskey
             = Userskey.10
       c     = c.11
       z     = fst(dec(c.11, Userskey.10))
    
    2. Userskey
             = KGCskey(x.11, x.12)
       c     = enc(x.13, KGCpkey(Get_Masterpkey(x.11), x.12))
       z     = fst(x.13)
    
    3. Userskey
             = KGCskey(x.17, x.18)
       c     = enc(<z.14, x.20>, KGCpkey(Get_Masterpkey(x.17), x.18))
       z     = z.14
  */

rule (modulo E) Sender_receive_check:
   [
   St_ReceiveKey_Oracle_plain( m_, ~Masterskey ), In( c_ ),
   St_ReceiveKey( ~m, Masterpkey ),
   In( enc(<~nonce, 'b', ~m>, KGCpkey(Masterpkey, 'b')) ),
   St_Receiver( Masterpkey, Userskey, ~ID, ~nonce )
   ]
  --[
  Finish( ), Notequalvalue( <~m, dec(c_, Userskey)> ), Secretmessage( ~m ),
  Commit( 'a', 'b', ~nonce )
  ]->
   [ ]

  /*
  rule (modulo AC) Sender_receive_check:
     [
     St_ReceiveKey_Oracle_plain( m_, ~Masterskey ), In( c_ ),
     St_ReceiveKey( ~m, Masterpkey ),
     In( enc(<~nonce, 'b', ~m>, KGCpkey(Masterpkey, 'b')) ),
     St_Receiver( Masterpkey, Userskey, ~ID, ~nonce )
     ]
    --[
    Finish( ), Notequalvalue( <~m, z> ), Secretmessage( ~m ),
    Commit( 'a', 'b', ~nonce )
    ]->
     [ ]
    variants (modulo AC)
    1. Userskey
             = Userskey.13
       c_    = c_.14
       z     = dec(c_.14, Userskey.13)
    
    2. Userskey
             = KGCskey(x.18, x.19)
       c_    = enc(z.15, KGCpkey(Get_Masterpkey(x.18), x.19))
       z     = z.15
  */

restriction OnlyOnce:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

lemma check_aliveness:
  all-traces
  "∀ x y t #i.
    (Commit( x, y, t ) @ #i) ⇒
    ((∃ id #j. Create_ID( y, id ) @ #j) ∨
     (∃ #r. Oracle( 'MsterKey', 'KGC' ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ x y t #i.
  (Commit( x, y, t ) @ #i)
 ∧
  (∀ id #j. (Create_ID( y, id ) @ #j) ⇒ ⊥) ∧
  (∀ #r. (Oracle( 'MsterKey', 'KGC' ) @ #r) ⇒ ⊥)"
*/
simplify
solve( St_ReceiveKey_Oracle_plain( m_, ~Masterskey ) ▶₀ #i )
  case Encrypt_Attacker
  solve( St_ReceiveKey( ~m, Masterpkey ) ▶₂ #i )
    case Sender_encrypt
    by solve( St_Receiver( Get_Masterpkey(~Masterskey), Userskey, ~ID, ~nonce
              ) ▶₄ #i )
  qed
qed

lemma check_noninjective_agreement:
  all-traces
  "∀ x y t #i.
    (Commit( x, y, t ) @ #i) ⇒
    (((∃ t.1 #j. Run( y, x, t.1 ) @ #j) ∨
      (∃ #r. Oracle( 'UserKey', 'b' ) @ #r)) ∨
     (∃ #j. Oracle( 'MsterKey', 'KGC' ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ x y t #i.
  (Commit( x, y, t ) @ #i)
 ∧
  (∀ t.1 #j. (Run( y, x, t.1 ) @ #j) ⇒ ⊥) ∧
  (∀ #r. (Oracle( 'UserKey', 'b' ) @ #r) ⇒ ⊥) ∧
  (∀ #j. (Oracle( 'MsterKey', 'KGC' ) @ #j) ⇒ ⊥)"
*/
simplify
solve( St_ReceiveKey_Oracle_plain( m_, ~Masterskey ) ▶₀ #i )
  case Encrypt_Attacker
  solve( St_ReceiveKey( ~m, Masterpkey ) ▶₂ #i )
    case Sender_encrypt
    by solve( St_Receiver( Get_Masterpkey(~Masterskey), Userskey, ~ID, ~nonce
              ) ▶₄ #i )
  qed
qed

lemma check_injective_agreement:
  all-traces
  "∀ x y t #i.
    (Commit( x, y, t ) @ #i) ⇒
    ((∃ #j.
       ((Run( y, x, t ) @ #j) ∧ (#j < #i)) ∧
       (¬(∃ z w #k. (Commit( z, w, t ) @ #k) ∧ (¬(#k = #i))))) ∨
     (∃ #r. Oracle( 'MsterKey', 'KGC' ) @ #r))"
/*
guarded formula characterizing all counter-examples:
"∃ x y t #i.
  (Commit( x, y, t ) @ #i)
 ∧
  (∀ #j.
    (Run( y, x, t ) @ #j)
   ⇒
    ((¬(#j < #i)) ∨ (∃ z w #k. (Commit( z, w, t ) @ #k) ∧ ¬(#k = #i)))) ∧
  (∀ #r. (Oracle( 'MsterKey', 'KGC' ) @ #r) ⇒ ⊥)"
*/
simplify
solve( St_ReceiveKey_Oracle_plain( m_, ~Masterskey ) ▶₀ #i )
  case Encrypt_Attacker
  solve( St_ReceiveKey( ~m, Masterpkey ) ▶₂ #i )
    case Sender_encrypt
    by solve( St_Receiver( Get_Masterpkey(~Masterskey), Userskey, ~ID, ~nonce
              ) ▶₄ #i )
  qed
qed

lemma nonce_secrecy:
  all-traces
  "∀ s #i.
    (Secret( s ) @ #i) ⇒
    ((((¬(∃ #j. K( s ) @ #j)) ∨ (∃ #l. Oracle( 'UserKey', 'a' ) @ #l)) ∨
      (∃ #l. Oracle( 'UserKey', 'b' ) @ #l)) ∨
     (∃ #l. Oracle( 'MsterKey', 'KGC' ) @ #l))"
/*
guarded formula characterizing all counter-examples:
"∃ s #i.
  (Secret( s ) @ #i)
 ∧
  (∃ #j. (K( s ) @ #j)) ∧
  (∀ #l. (Oracle( 'UserKey', 'a' ) @ #l) ⇒ ⊥) ∧
  (∀ #l. (Oracle( 'UserKey', 'b' ) @ #l) ⇒ ⊥) ∧
  (∀ #l. (Oracle( 'MsterKey', 'KGC' ) @ #l) ⇒ ⊥)"
*/
simplify
solve( Secret( s ) @ #i )
  case Encrypt_Attacker
  solve( !Make_Masterskey( ~Masterskey, 'KGC' ) ▶₀ #i )
    case Setup
    solve( St_Oracle( m_ ) ▶₃ #i )
      case Attacker_make_message
      solve( !KU( ~m ) @ #vk.10 )
        case Attacker_Get_Masterskey
        by contradiction /* from formulas */
      next
        case Attacker_make_message
        by solve( !KU( ~nonce ) @ #vk.1 )
      next
        case Sender_encrypt_case_1
        by solve( !KU( ~nonce ) @ #vk.1 )
      next
        case Sender_encrypt_case_2
        by solve( !KU( ~nonce ) @ #vk.1 )
      next
        case fresh
        by solve( !KU( ~nonce ) @ #vk.1 )
      qed
    qed
  qed
next
  case Sender_encrypt
  solve( !UserID( Masterpkey, Userskey, 'a', ~ID ) ▶₂ #i )
    case Create_Id
    solve( !KU( ~nonce ) @ #vk )
      case Sender_encrypt
      solve( !KU( KGCskey(~Masterskey, 'b') ) @ #vk.1 )
        case Attacker_Get_Usersey
        by contradiction /* from formulas */
      next
        case c_KGCskey
        solve( !KU( ~Masterskey ) @ #vk.2 )
          case Attacker_Get_Masterskey
          by contradiction /* from formulas */
        qed
      qed
    qed
  qed
qed

lemma ow_value_notequal:
  all-traces
  "∀ #i #j x.
    ((Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j x.
  (Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j) ∧ ¬(#i = #j)"
*/
simplify
solve( (#i < #j)  ∥ (#j < #i) )
  case case_1
  solve( St_ReceiveKey_Oracle_plain( m_, ~Masterskey ) ▶₀ #i )
    case Encrypt_Attacker
    solve( St_ReceiveKey( ~m, Masterpkey ) ▶₂ #i )
      case Sender_encrypt
      by solve( St_Receiver( Get_Masterpkey(~Masterskey), Userskey, ~ID, ~nonce
                ) ▶₄ #i )
    qed
  qed
next
  case case_2
  solve( St_ReceiveKey_Oracle_plain( m_, ~Masterskey ) ▶₀ #i )
    case Encrypt_Attacker
    solve( St_ReceiveKey( ~m, Masterpkey ) ▶₂ #i )
      case Sender_encrypt
      by solve( St_Receiver( Get_Masterpkey(~Masterskey), Userskey, ~ID, ~nonce
                ) ▶₄ #i )
    qed
  qed
qed

lemma ow_m_secret:
  all-traces "∀ m #i. (Secretmessage( m ) @ #i) ⇒ (¬(∃ #j. K( m ) @ #j))"
/*
guarded formula characterizing all counter-examples:
"∃ m #i. (Secretmessage( m ) @ #i) ∧ ∃ #j. (K( m ) @ #j)"
*/
simplify
solve( St_ReceiveKey_Oracle_plain( m_, ~Masterskey ) ▶₀ #i )
  case Encrypt_Attacker
  solve( St_ReceiveKey( ~m, Masterpkey ) ▶₂ #i )
    case Sender_encrypt
    by solve( St_Receiver( Get_Masterpkey(~Masterskey), Userskey, ~ID, ~nonce
              ) ▶₄ #i )
  qed
qed





















/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: code5-20250911.spthy

  processing time: 0.78s
  
  check_aliveness (all-traces): verified (4 steps)
  check_noninjective_agreement (all-traces): verified (4 steps)
  check_injective_agreement (all-traces): verified (4 steps)
  nonce_secrecy (all-traces): verified (16 steps)
  ow_value_notequal (all-traces): verified (8 steps)
  ow_m_secret (all-traces): verified (4 steps)

==============================================================================
