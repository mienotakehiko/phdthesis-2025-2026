Linear part: No equation.
Convergent part:
decrypt(encrypt(x,pk(y)),y) = x
Completing equations...
Completed equations:
decrypt(encrypt(x,pk(y)),y) = x
Process 0 (that is, the initial process):
(
    {1}out(c, pk(secretkey))
) | (
    {2}let pk_1: pkey = pk(secretkey) in
    {3}let c_1: bitstring = encrypt(m,pk_1) in
    {4}out(c, c_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}out(c, pk(secretkey))
) | (
    {2}let pk_1: pkey = pk(secretkey) in
    {3}let c_1: bitstring = encrypt(m,pk_1) in
    {4}out(c, c_1)
)

-- Query not attacker(m[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(m[])
RESULT not attacker(m[]) is true.
-- Non-interference m in process 1.
Warning: using "noninterf" in the presence of equations may yield many
false attacks. If you observe false attacks, try to code the desired
property using "choice" instead.
Translating the process into Horn clauses...
Completing...
goal reachable: bad

Derivation:

1. The message encrypt(m[],pk(secretkey[])) may be sent to the attacker at output {4}.
attacker(encrypt(m[],pk(secretkey[]))).

2. The message pk(secretkey[]) may be sent to the attacker at output {1}.
attacker(pk(secretkey[])).

3. The attacker has some term v.
attacker(v).

4. By 3, the attacker may know v.
By 2, the attacker may know pk(secretkey[]).
Using the function encrypt the attacker may obtain encrypt(v,pk(secretkey[])).
attacker(encrypt(v,pk(secretkey[]))).

5. By 4, the attacker may know encrypt(v,pk(secretkey[])).
By 1, the attacker may know encrypt(m[],pk(secretkey[])).
The terms encrypt(v,pk(secretkey[])) and encrypt(m[],pk(secretkey[])) unify for some values of the secrets and not for others.
The attacker tests equality between the two terms he knows, which may allow it to distinguish cases.
bad.


A more detailed output of the traces is available with
  set traceDisplay = long.

out(c, ~M) with ~M = encrypt(m,pk(secretkey)) at {4}

out(c, ~M_1) with ~M_1 = pk(secretkey) at {1}

The attacker tests whether
encrypt(a,~M_1) = encrypt(a,pk(secretkey))
is equal to
~M = encrypt(m,pk(secretkey)).
This gives the attacker some information on the secret.
A trace has been found.
RESULT Non-interference m cannot be proved.
-- Query not event(decsuccess) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not event(decsuccess)
RESULT not event(decsuccess) is true.

--------------------------------------------------------------
Verification summary:

Query not attacker(m[]) is true.

Non-interference m cannot be proved.

Query not event(decsuccess) is true.

--------------------------------------------------------------

