Linear part: No equation.
Convergent part:
decrypt(encrypt(x,pk(y),r),y) = x
Completing equations...
Completed equations:
decrypt(encrypt(x,pk(y),r),y) = x
Biprocess 0 (that is, the initial process):
{1}new nonce: bitstring;
(
    {2}out(c, pk(secretkey));
    {3}in(c, c_2: bitstring);
    {4}out(c, choice[nonce,c_2])
) | (
    {5}let pk_1: pkey = pk(secretkey) in
    {6}new randomvalue: bitstring;
    {7}let c_1: bitstring = encrypt(m,pk_1,randomvalue) in
    {8}out(c, c_1)
)

-- Observational equivalence in biprocess 1 (that is, biprocess 0, with let moved downwards):
{1}new nonce: bitstring;
(
    {2}out(c, pk(secretkey));
    {3}in(c, c_2: bitstring);
    {4}out(c, choice[nonce,c_2])
) | (
    {6}new randomvalue: bitstring;
    {5}let pk_1: pkey = pk(secretkey) in
    {7}let c_1: bitstring = encrypt(m,pk_1,randomvalue) in
    {8}out(c, c_1)
)

Translating the process into Horn clauses...
Termination warning: v ≠ v_1 && attacker2(v_2,v) && attacker2(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2(v,v_2) && attacker2(v_1,v_2) -> bad
Selecting 0
Completing...
Termination warning: v ≠ v_1 && attacker2(v_2,v) && attacker2(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2(v,v_2) && attacker2(v_1,v_2) -> bad
Selecting 0
goal reachable: any_val ≠ nonce[] -> bad

Derivation:

1. The attacker has some term c_3 (resp. c_4).
attacker2(c_3,c_4).

2. The message c_3 (resp. c_4) that the attacker may have by 1 may be received at input {3}.
So the message nonce[] (resp. c_4) may be sent to the attacker at output {4}.
attacker2(nonce[],c_4).

3. By 2, the attacker may know nonce[] (resp. c_4).
By 1, the attacker may know c_3 (resp. c_4).
We have nonce[] ≠ c_3.
The attacker tests equality between the two terms he knows, which may allow it to distinguish cases.
bad.


Unified c_3 with c_4
A more detailed output of the traces is available with
  set traceDisplay = long.

new nonce: bitstring creating nonce_1 at {1}

new randomvalue: bitstring creating randomvalue_1 at {6}

out(c, ~M) with ~M = encrypt(m,pk(secretkey),randomvalue_1) at {8}

out(c, ~M_1) with ~M_1 = pk(secretkey) at {2}

in(c, a) at {3}

out(c, ~M_2) with ~M_2 = choice[nonce_1,a] at {4}

The attacker tests whether
~M_2 = choice[nonce_1,a]
is equal to
a.
The result in the left-hand side is different from the result in the right-hand side.
A trace has been found.
RESULT Observational equivalence cannot be proved.
Looking for simplified processes ...
No simplified process found.

--------------------------------------------------------------
Verification summary:

Observational equivalence cannot be proved.

--------------------------------------------------------------

