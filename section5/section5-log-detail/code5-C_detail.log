Linear part: No equation.
Convergent part:
AEAD_MtE_Enc(k,n,p,ad) = enc((p,mac((n,ad,p),k)),k,n)
AEAD_MtE_Ad(enc((p,mac((n,ad,p),k)),k,n)) = ad
AEAD_MtE_N(enc((p,mac((n,ad,p),k)),k,n)) = n
AEAD_EtM_Enc(k,n,p,ad) = (enc(p,k,n),mac((n,ad,enc(p,k,n)),k))
AEAD_EtM_Ad((enc(p,k,n),mac((n,ad,enc(p,k,n)),k))) = ad
AEAD_EtM_N((enc(p,k,n),mac((n,ad,enc(p,k,n)),k))) = n
Completing equations...
Completed equations:
AEAD_EtM_N((enc(p,k,n),mac((n,ad,enc(p,k,n)),k))) = n
AEAD_EtM_Ad((enc(p,k,n),mac((n,ad,enc(p,k,n)),k))) = ad
AEAD_EtM_Enc(k,n,p,ad) = (enc(p,k,n),mac((n,ad,enc(p,k,n)),k))
AEAD_MtE_N(enc((p,mac((n,ad,p),k)),k,n)) = n
AEAD_MtE_Ad(enc((p,mac((n,ad,p),k)),k,n)) = ad
AEAD_MtE_Enc(k,n,p,ad) = enc((p,mac((n,ad,p),k)),k,n)
Biprocess 0 (that is, the initial process):
(
    {1}!
    {2}let Kaead_1: key = Kaead in
    {3}in(c, (na: bitstring,ada: bitstring,pa: bitstring));
    {4}out(c, AEAD_MtE_Enc(Kaead_1,na,pa,ada))
) | (
    {5}!
    {6}let Kaead_2: key = Kaead in
    {7}in(c, (na_1: bitstring,ada_1: bitstring,pa_1: bitstring));
    {8}out(c, AEAD_EtM_Enc(Kaead_2,na_1,pa_1,ada_1))
) | (
    {9}new t: bitstring;
    {10}new non: bitstring;
    {11}new ad: bitstring;
    {12}let CMtE: bitstring = AEAD_MtE_Enc(Kaead,non,t,ad) in
    {13}let CEtM: bitstring = AEAD_EtM_Enc(Kaead,non,t,ad) in
    {14}out(c, choice[CMtE,CEtM])
)

-- Observational equivalence in biprocess 1 (that is, biprocess 0, with let moved downwards):
(
    {1}!
    {3}in(c, (na: bitstring,ada: bitstring,pa: bitstring));
    {2}let Kaead_1: key = Kaead in
    {4}out(c, AEAD_MtE_Enc(Kaead_1,na,pa,ada))
) | (
    {5}!
    {7}in(c, (na_1: bitstring,ada_1: bitstring,pa_1: bitstring));
    {6}let Kaead_2: key = Kaead in
    {8}out(c, AEAD_EtM_Enc(Kaead_2,na_1,pa_1,ada_1))
) | (
    {9}new t: bitstring;
    {10}new non: bitstring;
    {11}new ad: bitstring;
    {13}let CEtM: bitstring = AEAD_EtM_Enc(Kaead,non,t,ad) in
    {12}let CMtE: bitstring = AEAD_MtE_Enc(Kaead,non,t,ad) in
    {14}out(c, choice[CMtE,CEtM])
)

Translating the process into Horn clauses...
Termination warning: v ≠ v_1 && attacker2(v_2,v) && attacker2(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2(v,v_2) && attacker2(v_1,v_2) -> bad
Selecting 0
Completing...
Termination warning: v ≠ v_1 && attacker2(v_2,v) && attacker2(v_2,v_1) -> bad
Selecting 0
Termination warning: v ≠ v_1 && attacker2(v,v_2) && attacker2(v_1,v_2) -> bad
Selecting 0
goal reachable: bad

Derivation:

1. The message enc((t[],mac((non[],ad[],t[]),Kaead[])),Kaead[],non[]) (resp. (enc(t[],Kaead[],non[]),mac((non[],ad[],enc(t[],Kaead[],non[])),Kaead[]))) may be sent to the attacker at output {14}.
attacker2(enc((t[],mac((non[],ad[],t[]),Kaead[])),Kaead[],non[]),(enc(t[],Kaead[],non[]),mac((non[],ad[],enc(t[],Kaead[],non[])),Kaead[]))).

2. By 1, the attacker may know enc((t[],mac((non[],ad[],t[]),Kaead[])),Kaead[],non[]) (resp. (enc(t[],Kaead[],non[]),mac((non[],ad[],enc(t[],Kaead[],non[])),Kaead[]))).
Using the function 1-proj-2-tuple the attacker may obtain fail-any_type (resp. enc(t[],Kaead[],non[])).
attacker2(fail-any_type,enc(t[],Kaead[],non[])).

3. By 2, the attacker may know fail-any_type (resp. enc(t[],Kaead[],non[])).
So the attacker may test the failure of this term, which may allow it to distinguish cases.
bad.


Initial state

Additional knowledge of the attacker:
c
--------------------------------------------------------------
New processes:
    (
        !
        in(c, (na: bitstring,ada: bitstring,pa: bitstring));
        let Kaead_1: key = Kaead in
        out(c, AEAD_MtE_Enc(Kaead_1,na,pa,ada))
    ) | (
        !
        in(c, (na_1: bitstring,ada_1: bitstring,pa_1: bitstring));
        let Kaead_2: key = Kaead in
        out(c, AEAD_EtM_Enc(Kaead_2,na_1,pa_1,ada_1))
    ) | (
        new t: bitstring;
        new non: bitstring;
        new ad: bitstring;
        let CEtM: bitstring = AEAD_EtM_Enc(Kaead,non,t,ad) in
        let CMtE: bitstring = AEAD_MtE_Enc(Kaead,non,t,ad) in
        out(c, choice[CMtE,CEtM])
    )

--------------------------------------------------------------
1st process: Reduction |

2nd process: Reduction |

3rd process: new t: bitstring creating t_1

3rd process: new non: bitstring creating non_1

3rd process: new ad: bitstring creating ad_1

3rd process: let CEtM: bitstring = AEAD_EtM_Enc(Kaead,non_1,t_1,ad_1) succeeds

3rd process: let CMtE: bitstring = AEAD_MtE_Enc(Kaead,non_1,t_1,ad_1) succeeds

3rd process: out(c, ~M) with ~M = choice[AEAD_MtE_Enc(Kaead,non_1,t_1,ad_1),AEAD_EtM_Enc(Kaead,non_1,t_1,ad_1)] done

Additional knowledge of the attacker:
1-proj-2-tuple(~M) = choice[fail-any_type,enc(t_1,Kaead,non_1)]
~M = choice[AEAD_MtE_Enc(Kaead,non_1,t_1,ad_1),AEAD_EtM_Enc(Kaead,non_1,t_1,ad_1)]
--------------------------------------------------------------
3rd process: Reduction 0

2nd process: Reduction ! 0 copy(ies)

1st process: Reduction ! 0 copy(ies)

New processes:

--------------------------------------------------------------
The attacker tests whether 1-proj-2-tuple(~M) = choice[fail-any_type,enc(t_1,Kaead,non_1)] is fail.
This holds on one side and not on the other.
A trace has been found.
RESULT Observational equivalence cannot be proved.
Looking for simplified processes ...
No simplified process found.

--------------------------------------------------------------
Verification summary:

Observational equivalence cannot be proved.

--------------------------------------------------------------

