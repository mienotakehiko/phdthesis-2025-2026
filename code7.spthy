//  (* Code.7: ID_Base_bone_franklin_formalization  for TAMF-01*)
theory ID_Base_bone_franklin_CPA_formalization
begin

builtins: bilinear-pairing, xor, hashing
functions: Make_Masterskey/2, UserID/4, enc/2, dec/2, HashA/1, HashB/1

rule Setup:
  let 
  Masterpkey = pmult(~Masterskey, 'Public')
  in
  [Fr(~Masterskey)] --[OnlyOnce()]-> [!Make_Masterskey(~Masterskey, 'KGC'), Out(<'Masterpkey', 'KGC'>)]

rule Create_Id:
  let Masterpkey = pmult(Masterskey, 'Public')
  ID1 = HashA($User)
  Userskey = pmult(Masterskey, ID1)
  in
  [Fr(~ID), !Make_Masterskey(Masterskey, 'KGC')] --[OnlyOnce(), Create_ID($User, <Masterpkey, Userskey>)]->
  [!UserID(Masterpkey, Userskey, $User, ~ID)]

rule Attacker_Get_Masterskey:
  [!Make_Masterskey(Masterskey ,'KGC')] --[Oracle('MsterKey', 'KGC')]-> [Out(Masterskey)]

rule Attacker_Get_Usersey:
  [ !UserID(Masterpkey, Userskey, $User, ~ID)] --[Oracle('UserKey', $User)]-> [Out(Userskey)]

rule Attacker_make_message:
[Fr(m_)] --[ ]-> [ Out(<'MsterKey', 'KGC', m_>), St_Oracle(m_)]

rule Sender_encrypt:
   let 
   message = <~nonce, 'bob', ~m>
   PBobKey = HashA('bob')
   Encrypt1 = pmult(~r, 'Public')
   Encrypt2 = HashB(em(PBobKey, Masterpkey)^(~r)) XOR message
   Sendermessage = <Encrypt1, Encrypt2>
  in
  [Fr(~m), Fr(~nonce), Fr(~r), !UserID(Masterpkey, Userskey, 'alice', ~ID)] --[Secret(~nonce)]-> 
  [Out(Sendermessage), St_Sender(Masterpkey, Userskey, ~ID, ~nonce)]

rule Encrypt_Attacker:
[!Make_Masterskey(~Masterskey, 'KGC'), In(<'MsterKey', 'KGC', m_>), In(<'UserKey', $User, ~m>), St_Oracle(m_), Fr(~nonce)] --[Send('MsterKey', 'KGC', enc(<'MsterKey', 'KGC', m_>, ~Masterskey)), Secret(~nonce), Role('Oracle'), Attacker_send_plain(m_)]->
 [Out(enc(<'MsterKey', 'KGC', m_>, ~Masterskey)), St_ReceiveKey_Oracle_plain(m_, ~Masterskey)]

rule Receiver_message:
  let 
  HashB_ = HashB(em(Userskey, Encrypt1))
  message = Encrypt2 XOR HashB_
  nonce = fst(message)
  message_ = <nonce, 'rceivernonce'>
  Qalice = HashA('alice')
  Encrypt3 = pmult(~r, 'Public')
  Encrypt4 = HashB(em(Qalice, Masterpkey)^(~r)) XOR message_
  Receivermessage = <Encrypt3, Encrypt4>
  in
  [In(<Encrypt1, Encrypt2>), Fr(~r), !UserID(Masterpkey, Userskey, 'bob', ~ID)] --[ Run('bob', 'alice', nonce)]-> [Out(Receivermessage)]

rule Sender_receive_check:
 let 
 HashB_ = HashB(em(Userskey, Encrypt1))
 message = Encrypt2 XOR HashB_
 in
 [St_ReceiveKey_Oracle_plain(m_, ~Masterskey), St_Sender(Masterpkey, Userskey, ~ID, ~nonce), In(<Encrypt1,Encrypt2>)] 
 --[Finish(), Notequalvalue(<message, ~nonce>), Secretmessage(message), Commit('a', 'b', ~nonce)]-> []

restriction OnlyOnce:
 "All #i #j. OnlyOnce()@#i & OnlyOnce()@#j ==> #i = #j"

lemma check_aliveness:
  "All x y t #i. Commit(x,y,t)@i ==> (Ex id #j. Create_ID(y,id) @ j)
   | (Ex #r. Oracle('MsterKey', 'KGC')@r)"

lemma check_noninjective_agreement:
  "All x y t #i. Commit(x, y, t) @i ==> (Ex t #j. Run(y, x, t) @j)
        | (Ex #r. Oracle('UserKey', 'b')@r)
        | (Ex #j. Oracle('MsterKey', 'KGC')@j)"

lemma check_injective_agreement:
"All x y t #i. Commit(x, y, t) @i ==> (Ex #j. Run(y, x, t) @j & j < i & not (Ex z w #k. Commit(z, w, t) @k & not (#k = #i)))
| (Ex #r. Oracle('MsterKey', 'KGC')@r)"

lemma nonce_secrecy:
  "All s #i. Secret(s) @i ==> (not (Ex #j. K(s)@j)
      | (Ex #l. Oracle('UserKey','a')@l)
      | (Ex #l. Oracle('UserKey','b')@l)
      | (Ex #l. Oracle('MsterKey','KGC')@l))"

lemma ow_value_notequal:
 "All #i #j x. Notequalvalue(x)@i & Notequalvalue(x)@j ==> #i=#j"

lemma ow_m_secret:
 "All m #i. Secretmessage(m)@i ==> not (Ex #j. K(m)@j)"

end
