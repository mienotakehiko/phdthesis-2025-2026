Linear part: No equation.
Convergent part:
xor(xor(x,y),y) = x
xor(x,x) = zeros
xor(zeros,x) = x
xor(x,zeros) = x
con(divhead(mt),divrest(mt)) = mt
divhead(con(lmt,rmt)) = lmt
divrest(con(lmt,rmt)) = rmt
dec(enc(x,s),s) = x
o2b(b2o(xb)) = xb
b2o(o2b(xo)) = xo
Ocon(Odivhead(mt),Odivrest(mt)) = mt
Odivhead(Ocon(lmt,rmt)) = lmt
Odivrest(Ocon(lmt,rmt)) = rmt
con2octs(x,y) = o2b(Ocon(x,y))
oct1(x) = Odivhead(b2o(x))
oct2i2(x) = Odivrest(b2o(x))
Completing equations...
Completed equations:
oct2i2(o2b(Ocon(lmt,rmt))) = rmt
oct1(o2b(Ocon(lmt,rmt))) = lmt
con2octs(Odivhead(b2o(xb)),Odivrest(b2o(xb))) = xb
oct2i2(o2b(xo)) = Odivrest(xo)
oct1(o2b(xo)) = Odivhead(xo)
con2octs(Odivhead(mt),Odivrest(mt)) = o2b(mt)
oct2i2(x) = Odivrest(b2o(x))
oct1(x) = Odivhead(b2o(x))
con2octs(x,y) = o2b(Ocon(x,y))
Odivrest(Ocon(lmt,rmt)) = rmt
Odivhead(Ocon(lmt,rmt)) = lmt
Ocon(Odivhead(mt),Odivrest(mt)) = mt
b2o(o2b(xo)) = xo
o2b(b2o(xb)) = xb
dec(enc(x,s),s) = x
divrest(con(lmt,rmt)) = rmt
divhead(con(lmt,rmt)) = lmt
con(divhead(mt),divrest(mt)) = mt
xor(x,zeros) = x
xor(zeros,x) = x
xor(x,x) = zeros
xor(xor(x,y),y) = x
Process 0 (that is, the initial process):
(
    {1}new iv: bitstring;
    {2}out(cc, (iv,2));
    {3}out(d, (iv,ts,2));
    {4}!
    {5}out(dd, 2)
) | (
    {6}!
    {7}let prskey: bitstring = sskey in
    {8}in(d, (iv_1: bitstring,m: bitstring,n: nat));
    {9}if (n ≠ 1) then
    (
        {10}let tb: bitstring = divhead(m) in
        {11}let nb: bitstring = divrest(m) in
        {12}let cipb: bitstring = enc(xor(tb,iv_1),prskey) in
        {13}out(cc, (iv_1,cipb));
        {14}out(pubc, (iv_1,cipb));
        {15}out(d, (cipb,nb,n - 1))
    )
    else
        {16}let p: bitstring = con2octs(b2o(m),CPAD1) in
        {17}let cipb_1: bitstring = enc(xor(p,iv_1),prskey) in
        {18}out(pubc, (iv_1,cipb_1));
        {19}out(cc, (iv_1,cipb_1))
) | (
    {20}!
    {21}let prskey_1: bitstring = sskey in
    {22}in(dd, x2: nat);
    {23}in(cc, (ciphb1: bitstring,ciphb2: bitstring));
    {24}let plainb: bitstring = dec(ciphb2,prskey_1) in
    {25}if (ciphb2 = enc(plainb,prskey_1)) then
    {26}let plaina: bitstring = xor(plainb,ciphb1) in
    {27}if (plainb = xor(plaina,ciphb1)) then
    {28}let x3: nat = x2 - 1 in
    {29}if (x3 ≠ 0) then
    (
        {30}out(dd, x3);
        {31}in(ee, (x4: nat,tailce: bitstring));
        {32}if (x4 = x3) then
        {33}let conb: bitstring = con(plaina,tailce) in
        {34}out(ee, (x2,conb));
        {35}if (conb = ts) then
        {36}event SuccCBC
    )
    else
        {37}if (oct2i2(plaina) = CPAD1) then
        {38}let planac: oct = oct1(plaina) in
        {39}out(ee, (x2,o2b(planac)))
) | (
    {40}!
    {41}let psskey: bitstring = sskey in
    {42}in(pubc, (X: bitstring,Y: bitstring));
    {43}let py: bitstring = dec(Y,psskey) in
    {44}let xpy: bitstring = xor(X,py) in
    {45}if (Ccase1(X,Y) = true) then
        {46}out(pubc, oct1(py))
    else
        {47}if (Ccase2(X,Y) = true) then
        {48}out(pubc, oct2i2(py))
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}new iv: bitstring;
    {2}out(cc, (iv,2));
    {3}out(d, (iv,ts,2));
    {4}!
    {5}out(dd, 2)
) | (
    {6}!
    {8}in(d, (iv_1: bitstring,m: bitstring,n: nat));
    {7}let prskey: bitstring = sskey in
    {9}if (n ≠ 1) then
    (
        {10}let tb: bitstring = divhead(m) in
        {12}let cipb: bitstring = enc(xor(tb,iv_1),prskey) in
        {13}out(cc, (iv_1,cipb));
        {14}out(pubc, (iv_1,cipb));
        {11}let nb: bitstring = divrest(m) in
        {15}out(d, (cipb,nb,n - 1))
    )
    else
        {16}let p: bitstring = con2octs(b2o(m),CPAD1) in
        {17}let cipb_1: bitstring = enc(xor(p,iv_1),prskey) in
        {18}out(pubc, (iv_1,cipb_1));
        {19}out(cc, (iv_1,cipb_1))
) | (
    {20}!
    {22}in(dd, x2: nat);
    {23}in(cc, (ciphb1: bitstring,ciphb2: bitstring));
    {21}let prskey_1: bitstring = sskey in
    {24}let plainb: bitstring = dec(ciphb2,prskey_1) in
    {25}if (ciphb2 = enc(plainb,prskey_1)) then
    {26}let plaina: bitstring = xor(plainb,ciphb1) in
    {27}if (plainb = xor(plaina,ciphb1)) then
    {28}let x3: nat = x2 - 1 in
    {29}if (x3 ≠ 0) then
    (
        {30}out(dd, x3);
        {31}in(ee, (x4: nat,tailce: bitstring));
        {32}if (x4 = x3) then
        {33}let conb: bitstring = con(plaina,tailce) in
        {34}out(ee, (x2,conb));
        {35}if (conb = ts) then
        {36}event SuccCBC
    )
    else
        {37}if (oct2i2(plaina) = CPAD1) then
        {38}let planac: oct = oct1(plaina) in
        {39}out(ee, (x2,o2b(planac)))
) | (
    {40}!
    {42}in(pubc, (X: bitstring,Y: bitstring));
    {41}let psskey: bitstring = sskey in
    {43}let py: bitstring = dec(Y,psskey) in
    {45}if (Ccase1(X,Y) = true) then
        {46}out(pubc, oct1(py))
    else
        {47}if (Ccase2(X,Y) = true) then
        {48}out(pubc, oct2i2(py))
)

-- Query not attacker(ts[]) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 180 rules (40 with conclusion selected). Queue: 76 rules.
400 rules inserted. Base: 351 rules (66 with conclusion selected). Queue: 96 rules.
600 rules inserted. Base: 509 rules (105 with conclusion selected). Queue: 9 rules.
Starting query not attacker(ts[])
goal reachable: attacker(ts[])

Derivation:

1. The message (iv[],ts[],2) may be sent on channel d[] at output {3}.
mess(d[],(iv[],ts[],2)).

2. The message (iv[],ts[],2) that may be sent on channel d[] by 1 may be received at input {8}.
We have 2 ≠ 1.
So the message (iv[],enc(xor(divhead(ts[]),iv[]),sskey[])) may be sent to the attacker at output {14}.
attacker((iv[],enc(xor(divhead(ts[]),iv[]),sskey[]))).

3. By 2, the attacker may know (iv[],enc(xor(divhead(ts[]),iv[]),sskey[])).
Using the function 2-proj-2-tuple the attacker may obtain enc(xor(divhead(ts[]),iv[]),sskey[]).
attacker(enc(xor(divhead(ts[]),iv[]),sskey[])).

4. The message (iv[],ts[],2) that may be sent on channel d[] by 1 may be received at input {8}.
We have 1 ≠ 0.
So the message (enc(xor(divhead(ts[]),iv[]),sskey[]),divrest(ts[]),1) may be sent on channel d[] at output {15}.
mess(d[],(enc(xor(divhead(ts[]),iv[]),sskey[]),divrest(ts[]),1)).

5. The message (enc(xor(divhead(ts[]),iv[]),sskey[]),divrest(ts[]),1) that may be sent on channel d[] by 4 may be received at input {8}.
So the message (enc(xor(divhead(ts[]),iv[]),sskey[]),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])) may be sent to the attacker at output {18}.
attacker((enc(xor(divhead(ts[]),iv[]),sskey[]),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]))).

6. By 5, the attacker may know (enc(xor(divhead(ts[]),iv[]),sskey[]),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).
Using the function 2-proj-2-tuple the attacker may obtain enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]).
attacker(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).

7. By 6, the attacker may know enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]).
Using the function AB2 the attacker may obtain AB2(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).
attacker(AB2(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]))).

8. By 7, the attacker may know AB2(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).
By 6, the attacker may know enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]).
Using the function 2-tuple the attacker may obtain (AB2(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).
attacker((AB2(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]))).

9. The message (AB2(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])) that the attacker may have by 8 may be received at input {42}.
So the message Odivrest(b2o(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])))) may be sent to the attacker at output {48}.
attacker(Odivrest(b2o(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[]))))).

10. By 6, the attacker may know enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]).
Using the function AB1 the attacker may obtain AB1(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).
attacker(AB1(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]))).

11. By 10, the attacker may know AB1(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).
By 6, the attacker may know enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]).
Using the function 2-tuple the attacker may obtain (AB1(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])).
attacker((AB1(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]))).

12. The message (AB1(enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])) that the attacker may have by 11 may be received at input {42}.
So the message Odivhead(b2o(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])))) may be sent to the attacker at output {46}.
attacker(Odivhead(b2o(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[]))))).

13. By 12, the attacker may know Odivhead(b2o(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])))).
By 9, the attacker may know Odivrest(b2o(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])))).
Using the function con2octs the attacker may obtain xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])).
attacker(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[]))).

14. By 13, the attacker may know xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])).
By 3, the attacker may know enc(xor(divhead(ts[]),iv[]),sskey[]).
Using the function xor the attacker may obtain o2b(Ocon(b2o(divrest(ts[])),CPAD1)).
attacker(o2b(Ocon(b2o(divrest(ts[])),CPAD1))).

15. By 14, the attacker may know o2b(Ocon(b2o(divrest(ts[])),CPAD1)).
Using the function oct1 the attacker may obtain b2o(divrest(ts[])).
attacker(b2o(divrest(ts[]))).

16. By 15, the attacker may know b2o(divrest(ts[])).
Using the function o2b the attacker may obtain divrest(ts[]).
attacker(divrest(ts[])).

17. By 2, the attacker may know (iv[],enc(xor(divhead(ts[]),iv[]),sskey[])).
Using the function 1-proj-2-tuple the attacker may obtain iv[].
attacker(iv[]).

18. By 3, the attacker may know enc(xor(divhead(ts[]),iv[]),sskey[]).
Using the function AB2 the attacker may obtain AB2(enc(xor(divhead(ts[]),iv[]),sskey[])).
attacker(AB2(enc(xor(divhead(ts[]),iv[]),sskey[]))).

19. By 18, the attacker may know AB2(enc(xor(divhead(ts[]),iv[]),sskey[])).
By 3, the attacker may know enc(xor(divhead(ts[]),iv[]),sskey[]).
Using the function 2-tuple the attacker may obtain (AB2(enc(xor(divhead(ts[]),iv[]),sskey[])),enc(xor(divhead(ts[]),iv[]),sskey[])).
attacker((AB2(enc(xor(divhead(ts[]),iv[]),sskey[])),enc(xor(divhead(ts[]),iv[]),sskey[]))).

20. The message (AB2(enc(xor(divhead(ts[]),iv[]),sskey[])),enc(xor(divhead(ts[]),iv[]),sskey[])) that the attacker may have by 19 may be received at input {42}.
So the message Odivrest(b2o(xor(divhead(ts[]),iv[]))) may be sent to the attacker at output {48}.
attacker(Odivrest(b2o(xor(divhead(ts[]),iv[])))).

21. By 3, the attacker may know enc(xor(divhead(ts[]),iv[]),sskey[]).
Using the function AB1 the attacker may obtain AB1(enc(xor(divhead(ts[]),iv[]),sskey[])).
attacker(AB1(enc(xor(divhead(ts[]),iv[]),sskey[]))).

22. By 21, the attacker may know AB1(enc(xor(divhead(ts[]),iv[]),sskey[])).
By 3, the attacker may know enc(xor(divhead(ts[]),iv[]),sskey[]).
Using the function 2-tuple the attacker may obtain (AB1(enc(xor(divhead(ts[]),iv[]),sskey[])),enc(xor(divhead(ts[]),iv[]),sskey[])).
attacker((AB1(enc(xor(divhead(ts[]),iv[]),sskey[])),enc(xor(divhead(ts[]),iv[]),sskey[]))).

23. The message (AB1(enc(xor(divhead(ts[]),iv[]),sskey[])),enc(xor(divhead(ts[]),iv[]),sskey[])) that the attacker may have by 22 may be received at input {42}.
So the message Odivhead(b2o(xor(divhead(ts[]),iv[]))) may be sent to the attacker at output {46}.
attacker(Odivhead(b2o(xor(divhead(ts[]),iv[])))).

24. By 23, the attacker may know Odivhead(b2o(xor(divhead(ts[]),iv[]))).
By 20, the attacker may know Odivrest(b2o(xor(divhead(ts[]),iv[]))).
Using the function con2octs the attacker may obtain xor(divhead(ts[]),iv[]).
attacker(xor(divhead(ts[]),iv[])).

25. By 24, the attacker may know xor(divhead(ts[]),iv[]).
By 17, the attacker may know iv[].
Using the function xor the attacker may obtain divhead(ts[]).
attacker(divhead(ts[])).

26. By 25, the attacker may know divhead(ts[]).
By 16, the attacker may know divrest(ts[]).
Using the function con the attacker may obtain ts[].
attacker(ts[]).

27. By 26, attacker(ts[]).
The goal is reached, represented in the following fact:
attacker(ts[]).


Could not find a trace corresponding to this derivation.
RESULT not attacker(ts[]) cannot be proved.
-- Query not event(SuccCBC) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 177 rules (40 with conclusion selected). Queue: 80 rules.
400 rules inserted. Base: 347 rules (62 with conclusion selected). Queue: 50 rules.
600 rules inserted. Base: 504 rules (105 with conclusion selected). Queue: 11 rules.
Starting query not event(SuccCBC)
goal reachable: event(SuccCBC)

Derivation:

1. The message 2 may be sent on channel dd[] at output {5}.
mess(dd[],2).

2. The message (iv[],ts[],2) may be sent on channel d[] at output {3}.
mess(d[],(iv[],ts[],2)).

3. The message (iv[],ts[],2) that may be sent on channel d[] by 2 may be received at input {8}.
We have 2 ≠ 1.
So the message (iv[],enc(xor(divhead(ts[]),iv[]),sskey[])) may be sent on channel cc[] at output {13}.
mess(cc[],(iv[],enc(xor(divhead(ts[]),iv[]),sskey[]))).

4. The message 2 may be sent on channel dd[] at output {5}.
mess(dd[],2).

5. The message (iv[],ts[],2) that may be sent on channel d[] by 2 may be received at input {8}.
We have 2 ≠ 1.
So the message (iv[],enc(xor(divhead(ts[]),iv[]),sskey[])) may be sent on channel cc[] at output {13}.
mess(cc[],(iv[],enc(xor(divhead(ts[]),iv[]),sskey[]))).

6. The message 2 that may be sent on channel dd[] by 4 may be received at input {22}.
The message (iv[],enc(xor(divhead(ts[]),iv[]),sskey[])) that may be sent on channel cc[] by 5 may be received at input {23}.
We have 1 ≠ 0.
So the message 1 may be sent on channel dd[] at output {30}.
mess(dd[],1).

7. The message (iv[],ts[],2) that may be sent on channel d[] by 2 may be received at input {8}.
We have 1 ≠ 0.
So the message (enc(xor(divhead(ts[]),iv[]),sskey[]),divrest(ts[]),1) may be sent on channel d[] at output {15}.
mess(d[],(enc(xor(divhead(ts[]),iv[]),sskey[]),divrest(ts[]),1)).

8. The message (enc(xor(divhead(ts[]),iv[]),sskey[]),divrest(ts[]),1) that may be sent on channel d[] by 7 may be received at input {8}.
So the message (enc(xor(divhead(ts[]),iv[]),sskey[]),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])) may be sent on channel cc[] at output {19}.
mess(cc[],(enc(xor(divhead(ts[]),iv[]),sskey[]),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[]))).

9. The message 1 that may be sent on channel dd[] by 6 may be received at input {22}.
The message (enc(xor(divhead(ts[]),iv[]),sskey[]),enc(xor(o2b(Ocon(b2o(divrest(ts[])),CPAD1)),enc(xor(divhead(ts[]),iv[]),sskey[])),sskey[])) that may be sent on channel cc[] by 8 may be received at input {23}.
So the message (1,divrest(ts[])) may be sent on channel ee[] at output {39}.
mess(ee[],(1,divrest(ts[]))).

10. The message 2 that may be sent on channel dd[] by 1 may be received at input {22}.
The message (iv[],enc(xor(divhead(ts[]),iv[]),sskey[])) that may be sent on channel cc[] by 3 may be received at input {23}.
The message (1,divrest(ts[])) that may be sent on channel ee[] by 9 may be received at input {31}.
We have 1 ≠ 0.
So event SuccCBC may be executed at {36}.
event(SuccCBC).

11. By 10, event(SuccCBC).
The goal is reached, represented in the following fact:
event(SuccCBC).


Could not find a trace corresponding to this derivation.
RESULT not event(SuccCBC) cannot be proved.

--------------------------------------------------------------
Verification summary:

Query not attacker(ts[]) cannot be proved.

Query not event(SuccCBC) cannot be proved.

--------------------------------------------------------------

