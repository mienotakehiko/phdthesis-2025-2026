Linear part: No equation.
Convergent part:
xor(xor(x,y),y) = x
xor(x,x) = zeros
xor(zeros,x) = x
xor(x,zeros) = x
con(divhead(mt),divrest(mt)) = mt
divhead(con(lmt,rmt)) = lmt
divrest(con(lmt,rmt)) = rmt
dec(enc(x,s),s) = x
Completing equations...
Completed equations:
dec(enc(x,s),s) = x
divrest(con(lmt,rmt)) = rmt
divhead(con(lmt,rmt)) = lmt
con(divhead(mt),divrest(mt)) = mt
xor(x,zeros) = x
xor(zeros,x) = x
xor(x,x) = zeros
xor(xor(x,y),y) = x
Process 0 (that is, the initial process):
(
    {1}new iv: bitstring;
    {2}let tb: bitstring = divhead(ts) in
    {3}let nb: bitstring = divrest(ts) in
    {4}let civ: bitstring = enc(iv,sskey) in
    {5}out(pubc, iv);
    {6}out(cc, (civ,2));
    {7}out(d, (civ,ts,2));
    {8}!
    {9}out(dd, 2)
) | (
    {10}!
    {11}let prskey: bitstring = sskey in
    {12}in(d, (iv_1: bitstring,m: bitstring,n: nat));
    {13}if (n ≠ 1) then
    (
        {14}let tb_1: bitstring = divhead(m) in
        {15}let nb_1: bitstring = divrest(m) in
        {16}let cipb: bitstring = enc(xor(tb_1,iv_1),prskey) in
        {17}out(cc, (iv_1,cipb));
        {18}out(pubc, (iv_1,cipb));
        {19}out(d, (cipb,nb_1,n - 1))
    )
    else
        {20}let cipb_1: bitstring = enc(xor(m,iv_1),prskey) in
        {21}out(pubc, (iv_1,cipb_1));
        {22}out(cc, (iv_1,cipb_1))
) | (
    {23}!
    {24}let prskey_1: bitstring = sskey in
    {25}in(dd, x2: nat);
    {26}in(cc, (ciphb1: bitstring,ciphb2: bitstring));
    {27}let plainb: bitstring = dec(ciphb2,prskey_1) in
    {28}if (ciphb2 = enc(plainb,prskey_1)) then
    {29}let plaina: bitstring = xor(plainb,ciphb1) in
    {30}if (plainb = xor(plaina,ciphb1)) then
    {31}let x3: nat = x2 - 1 in
    {32}if (x3 ≠ 0) then
    (
        {33}out(dd, x3);
        {34}in(ee, (x4: nat,tiv: bitstring,tailce: bitstring));
        {35}if ((x4 = x3) && (tiv = ciphb2)) then
        {36}let conb: bitstring = con(plaina,tailce) in
        {37}out(ee, (x2,ciphb1,conb));
        {38}in(pubc, X: bitstring);
        {39}if (conb = con(X,ts)) then
        {40}event SuccCBC
    )
    else
        {41}out(ee, (x2,ciphb1,plaina))
) | (
    {42}!
    {43}let n_1: nat = 3 in
    {44}in(pubc, (iv_2: bitstring,m_1: bitstring));
    {45}out(cc, (iv_2,n_1));
    {46}out(d, (iv_2,m_1,n_1));
    {47}!
    {48}out(dd, n_1)
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}new iv: bitstring;
    {5}out(pubc, iv);
    {4}let civ: bitstring = enc(iv,sskey) in
    {6}out(cc, (civ,2));
    {7}out(d, (civ,ts,2));
    {8}!
    {9}out(dd, 2)
) | (
    {10}!
    {12}in(d, (iv_1: bitstring,m: bitstring,n: nat));
    {11}let prskey: bitstring = sskey in
    {13}if (n ≠ 1) then
    (
        {14}let tb_1: bitstring = divhead(m) in
        {16}let cipb: bitstring = enc(xor(tb_1,iv_1),prskey) in
        {17}out(cc, (iv_1,cipb));
        {18}out(pubc, (iv_1,cipb));
        {15}let nb_1: bitstring = divrest(m) in
        {19}out(d, (cipb,nb_1,n - 1))
    )
    else
        {20}let cipb_1: bitstring = enc(xor(m,iv_1),prskey) in
        {21}out(pubc, (iv_1,cipb_1));
        {22}out(cc, (iv_1,cipb_1))
) | (
    {23}!
    {25}in(dd, x2: nat);
    {26}in(cc, (ciphb1: bitstring,ciphb2: bitstring));
    {24}let prskey_1: bitstring = sskey in
    {27}let plainb: bitstring = dec(ciphb2,prskey_1) in
    {28}if (ciphb2 = enc(plainb,prskey_1)) then
    {29}let plaina: bitstring = xor(plainb,ciphb1) in
    {30}if (plainb = xor(plaina,ciphb1)) then
    {31}let x3: nat = x2 - 1 in
    {32}if (x3 ≠ 0) then
    (
        {33}out(dd, x3);
        {34}in(ee, (x4: nat,tiv: bitstring,tailce: bitstring));
        {35}if ((x4 = x3) && (tiv = ciphb2)) then
        {36}let conb: bitstring = con(plaina,tailce) in
        {37}out(ee, (x2,ciphb1,conb));
        {38}in(pubc, X: bitstring);
        {39}if (conb = con(X,ts)) then
        {40}event SuccCBC
    )
    else
        {41}out(ee, (x2,ciphb1,plaina))
) | (
    {42}!
    {44}in(pubc, (iv_2: bitstring,m_1: bitstring));
    {43}let n_1: nat = 3 in
    {45}out(cc, (iv_2,n_1));
    {46}out(d, (iv_2,m_1,n_1));
    {47}!
    {48}out(dd, n_1)
)

-- Query not event(SuccCBC) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 177 rules (37 with conclusion selected). Queue: 94 rules.
400 rules inserted. Base: 276 rules (61 with conclusion selected). Queue: 199 rules.
600 rules inserted. Base: 388 rules (89 with conclusion selected). Queue: 239 rules.
800 rules inserted. Base: 477 rules (93 with conclusion selected). Queue: 190 rules.
1000 rules inserted. Base: 520 rules (95 with conclusion selected). Queue: 155 rules.
1200 rules inserted. Base: 571 rules (123 with conclusion selected). Queue: 217 rules.
1400 rules inserted. Base: 664 rules (133 with conclusion selected). Queue: 327 rules.
1600 rules inserted. Base: 725 rules (135 with conclusion selected). Queue: 414 rules.
1800 rules inserted. Base: 742 rules (140 with conclusion selected). Queue: 487 rules.
2000 rules inserted. Base: 797 rules (147 with conclusion selected). Queue: 516 rules.
2200 rules inserted. Base: 848 rules (161 with conclusion selected). Queue: 507 rules.
2400 rules inserted. Base: 905 rules (183 with conclusion selected). Queue: 543 rules.
2600 rules inserted. Base: 1036 rules (231 with conclusion selected). Queue: 775 rules.
2800 rules inserted. Base: 1200 rules (274 with conclusion selected). Queue: 982 rules.
3000 rules inserted. Base: 1320 rules (308 with conclusion selected). Queue: 1144 rules.
3200 rules inserted. Base: 1506 rules (308 with conclusion selected). Queue: 1147 rules.
3400 rules inserted. Base: 1694 rules (308 with conclusion selected). Queue: 1148 rules.
3600 rules inserted. Base: 1880 rules (308 with conclusion selected). Queue: 1154 rules.
3800 rules inserted. Base: 2047 rules (308 with conclusion selected). Queue: 1247 rules.
4000 rules inserted. Base: 2233 rules (308 with conclusion selected). Queue: 1252 rules.
4200 rules inserted. Base: 2377 rules (316 with conclusion selected). Queue: 1410 rules.
4400 rules inserted. Base: 2497 rules (316 with conclusion selected). Queue: 1645 rules.
4600 rules inserted. Base: 2620 rules (316 with conclusion selected). Queue: 1867 rules.
4800 rules inserted. Base: 2741 rules (316 with conclusion selected). Queue: 2102 rules.
5000 rules inserted. Base: 2837 rules (316 with conclusion selected). Queue: 2139 rules.
5200 rules inserted. Base: 2961 rules (316 with conclusion selected). Queue: 2359 rules.
5400 rules inserted. Base: 3090 rules (318 with conclusion selected). Queue: 2400 rules.
5600 rules inserted. Base: 3182 rules (318 with conclusion selected). Queue: 2350 rules.
5800 rules inserted. Base: 3275 rules (318 with conclusion selected). Queue: 2302 rules.
6000 rules inserted. Base: 3371 rules (318 with conclusion selected). Queue: 2244 rules.
6200 rules inserted. Base: 3465 rules (318 with conclusion selected). Queue: 2193 rules.
6400 rules inserted. Base: 3557 rules (318 with conclusion selected). Queue: 2143 rules.
6600 rules inserted. Base: 3657 rules (318 with conclusion selected). Queue: 2082 rules.
6800 rules inserted. Base: 3752 rules (318 with conclusion selected). Queue: 2032 rules.
7000 rules inserted. Base: 3905 rules (318 with conclusion selected). Queue: 1900 rules.
7200 rules inserted. Base: 4000 rules (318 with conclusion selected). Queue: 1842 rules.
7400 rules inserted. Base: 4096 rules (318 with conclusion selected). Queue: 1790 rules.
7600 rules inserted. Base: 4189 rules (318 with conclusion selected). Queue: 1742 rules.
7800 rules inserted. Base: 4356 rules (318 with conclusion selected). Queue: 1711 rules.
8000 rules inserted. Base: 4544 rules (318 with conclusion selected). Queue: 1526 rules.
8200 rules inserted. Base: 4732 rules (318 with conclusion selected). Queue: 1342 rules.
8400 rules inserted. Base: 4920 rules (318 with conclusion selected). Queue: 1156 rules.
8600 rules inserted. Base: 5104 rules (318 with conclusion selected). Queue: 976 rules.
8800 rules inserted. Base: 5288 rules (318 with conclusion selected). Queue: 796 rules.
9000 rules inserted. Base: 5476 rules (318 with conclusion selected). Queue: 611 rules.
9200 rules inserted. Base: 5664 rules (318 with conclusion selected). Queue: 426 rules.
9400 rules inserted. Base: 5823 rules (318 with conclusion selected). Queue: 285 rules.
9600 rules inserted. Base: 5976 rules (318 with conclusion selected). Queue: 260 rules.
9800 rules inserted. Base: 6146 rules (318 with conclusion selected). Queue: 129 rules.
Starting query not event(SuccCBC)
goal reachable: event(SuccCBC)

Derivation:

1. The attacker has some term m_2.
attacker(m_2).

2. The attacker has some term iv_3.
attacker(iv_3).

3. By 2, the attacker may know iv_3.
By 1, the attacker may know m_2.
Using the function 2-tuple the attacker may obtain (iv_3,m_2).
attacker((iv_3,m_2)).

4. The message (iv_3,m_2) that the attacker may have by 3 may be received at input {44}.
So the message 3 may be sent on channel dd[] at output {48}.
mess(dd[],3).

5. The attacker has some term rmt.
attacker(rmt).

6. The message iv[] may be sent to the attacker at output {5}.
attacker(iv[]).

7. By 6, the attacker may know iv[].
By 6, the attacker may know iv[].
Using the function xor the attacker may obtain xor(iv[],iv[]).
attacker(xor(iv[],iv[])).

8. By 7, the attacker may know xor(iv[],iv[]).
By 5, the attacker may know rmt.
Using the function con the attacker may obtain con(xor(iv[],iv[]),rmt).
attacker(con(xor(iv[],iv[]),rmt)).

9. By 6, the attacker may know iv[].
By 8, the attacker may know con(xor(iv[],iv[]),rmt).
Using the function 2-tuple the attacker may obtain (iv[],con(xor(iv[],iv[]),rmt)).
attacker((iv[],con(xor(iv[],iv[]),rmt))).

10. The message (iv[],con(xor(iv[],iv[]),rmt)) that the attacker may have by 9 may be received at input {44}.
So the message (iv[],con(xor(iv[],iv[]),rmt),3) may be sent on channel d[] at output {46}.
mess(d[],(iv[],con(xor(iv[],iv[]),rmt),3)).

11. The message (iv[],con(xor(iv[],iv[]),rmt),3) that may be sent on channel d[] by 10 may be received at input {12}.
We have 3 ≠ 1.
So the message (iv[],enc(iv[],sskey[])) may be sent on channel cc[] at output {17}.
mess(cc[],(iv[],enc(iv[],sskey[]))).

12. The message 2 may be sent on channel dd[] at output {9}.
mess(dd[],2).

13. The message (enc(iv[],sskey[]),ts[],2) may be sent on channel d[] at output {7}.
mess(d[],(enc(iv[],sskey[]),ts[],2)).

14. The message (enc(iv[],sskey[]),ts[],2) that may be sent on channel d[] by 13 may be received at input {12}.
We have 2 ≠ 1.
So the message (enc(iv[],sskey[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[])) may be sent on channel cc[] at output {17}.
mess(cc[],(enc(iv[],sskey[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]))).

15. The message 2 may be sent on channel dd[] at output {9}.
mess(dd[],2).

16. The message (enc(iv[],sskey[]),ts[],2) that may be sent on channel d[] by 13 may be received at input {12}.
We have 2 ≠ 1.
So the message (enc(iv[],sskey[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[])) may be sent on channel cc[] at output {17}.
mess(cc[],(enc(iv[],sskey[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]))).

17. The message 2 that may be sent on channel dd[] by 15 may be received at input {25}.
The message (enc(iv[],sskey[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[])) that may be sent on channel cc[] by 16 may be received at input {26}.
We have 1 ≠ 0.
So the message 1 may be sent on channel dd[] at output {33}.
mess(dd[],1).

18. The message (enc(iv[],sskey[]),ts[],2) that may be sent on channel d[] by 13 may be received at input {12}.
We have 1 ≠ 0.
So the message (enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),divrest(ts[]),1) may be sent on channel d[] at output {19}.
mess(d[],(enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),divrest(ts[]),1)).

19. The message (enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),divrest(ts[]),1) that may be sent on channel d[] by 18 may be received at input {12}.
So the message (enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),enc(xor(divrest(ts[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[])),sskey[])) may be sent on channel cc[] at output {22}.
mess(cc[],(enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),enc(xor(divrest(ts[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[])),sskey[]))).

20. The message 1 that may be sent on channel dd[] by 17 may be received at input {25}.
The message (enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),enc(xor(divrest(ts[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[])),sskey[])) that may be sent on channel cc[] by 19 may be received at input {26}.
So the message (1,enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),divrest(ts[])) may be sent on channel ee[] at output {41}.
mess(ee[],(1,enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),divrest(ts[]))).

21. The message 2 that may be sent on channel dd[] by 12 may be received at input {25}.
The message (enc(iv[],sskey[]),enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[])) that may be sent on channel cc[] by 14 may be received at input {26}.
The message (1,enc(xor(divhead(ts[]),enc(iv[],sskey[])),sskey[]),divrest(ts[])) that may be sent on channel ee[] by 20 may be received at input {34}.
We have 1 ≠ 0.
So the message (2,enc(iv[],sskey[]),ts[]) may be sent on channel ee[] at output {37}.
mess(ee[],(2,enc(iv[],sskey[]),ts[])).

22. Using the function zeros the attacker may obtain zeros.
attacker(zeros).

23. The message 3 that may be sent on channel dd[] by 4 may be received at input {25}.
The message (iv[],enc(iv[],sskey[])) that may be sent on channel cc[] by 11 may be received at input {26}.
The message (2,enc(iv[],sskey[]),ts[]) that may be sent on channel ee[] by 21 may be received at input {34}.
The message zeros that the attacker may have by 22 may be received at input {38}.
We have 2 ≠ 0.
So event SuccCBC may be executed at {40}.
event(SuccCBC).

24. By 23, event(SuccCBC).
The goal is reached, represented in the following fact:
event(SuccCBC).


Could not find a trace corresponding to this derivation.
RESULT not event(SuccCBC) cannot be proved.

--------------------------------------------------------------
Verification summary:

Query not event(SuccCBC) cannot be proved.

--------------------------------------------------------------

