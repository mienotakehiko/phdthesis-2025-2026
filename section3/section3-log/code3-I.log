Linear part: No equation.
Convergent part:
con(divhead(mt),divrest(mt)) = mt
Completing equations...
Completed equations:
con(divhead(mt),divrest(mt)) = mt
Process 0 (that is, the initial process):
(
    {1}new m1: bitstring;
    {2}new m2: bitstring;
    {3}out(c, (m2,2));
    {4}out(t, (iv,m1,2,length(m1),m1));
    {11}get MD_h_len(=m1,MDh1': bitstring) in
    {5}out(c, MDh1');
    {6}out(s, (iv,m1,2,m1));
    {10}get MD_h(=m1,MDh1: bitstring) in
    {7}out(t, (MDh1,m2,2,length(con(m1,m2)),con(m1,m2)));
    {9}get MD_h_len(=con(m1,m2),MDh12: bitstring) in
    {8}insert MD_h_check(MDh12)
) | (
    {12}!
    {13}in(s, (ha: bitstring,rm: bitstring,bl: nat,mm: bitstring));
    {14}if (bl ≠ 1) then
    (
        {15}let newbl: bitstring = divhead(rm) in
        {16}let newstream: bitstring = divrest(rm) in
        {17}let newha: bitstring = comp(ha,newbl) in
        {18}out(s, (newha,newstream,bl - 1,mm))
    )
    else
        {19}let MDh: bitstring = comp(ha,rm) in
        {20}insert MD_h(mm,MDh)
) | (
    {21}!
    {22}in(t, (ha_1: bitstring,rm_1: bitstring,bl_1: nat,len: bitstring,mm_1: bitstring));
    {23}if (bl_1 ≠ 1) then
    (
        {24}let newbl_1: bitstring = divhead(rm_1) in
        {25}let newstream_1: bitstring = divrest(rm_1) in
        {26}let newha_1: bitstring = comp(ha_1,newbl_1) in
        {27}out(t, (newha_1,newstream_1,bl_1 - 1,len,mm_1))
    )
    else
        {28}let newha_2: bitstring = comp(ha_1,rm_1) in
        {29}let MDh_1: bitstring = comp(newha_2,len) in
        {30}insert MD_h_len(mm_1,MDh_1)
) | (
    {31}!
    {32}in(c, MDh12': bitstring);
    {34}get MD_h_check(=MDh12') in
    {33}event SUCCESS
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}new m1: bitstring;
    {2}new m2: bitstring;
    {3}out(c, (m2,2));
    {4}out(t, (iv,m1,2,length(m1),m1));
    {11}get MD_h_len(=m1,MDh1': bitstring) in
    {5}out(c, MDh1');
    {6}out(s, (iv,m1,2,m1));
    {10}get MD_h(=m1,MDh1: bitstring) in
    {7}out(t, (MDh1,m2,2,length(con(m1,m2)),con(m1,m2)));
    {9}get MD_h_len(=con(m1,m2),MDh12: bitstring) in
    {8}insert MD_h_check(MDh12)
) | (
    {12}!
    {13}in(s, (ha: bitstring,rm: bitstring,bl: nat,mm: bitstring));
    {14}if (bl ≠ 1) then
    (
        {15}let newbl: bitstring = divhead(rm) in
        {17}let newha: bitstring = comp(ha,newbl) in
        {16}let newstream: bitstring = divrest(rm) in
        {18}out(s, (newha,newstream,bl - 1,mm))
    )
    else
        {19}let MDh: bitstring = comp(ha,rm) in
        {20}insert MD_h(mm,MDh)
) | (
    {21}!
    {22}in(t, (ha_1: bitstring,rm_1: bitstring,bl_1: nat,len: bitstring,mm_1: bitstring));
    {23}if (bl_1 ≠ 1) then
    (
        {24}let newbl_1: bitstring = divhead(rm_1) in
        {26}let newha_1: bitstring = comp(ha_1,newbl_1) in
        {25}let newstream_1: bitstring = divrest(rm_1) in
        {27}out(t, (newha_1,newstream_1,bl_1 - 1,len,mm_1))
    )
    else
        {28}let newha_2: bitstring = comp(ha_1,rm_1) in
        {29}let MDh_1: bitstring = comp(newha_2,len) in
        {30}insert MD_h_len(mm_1,MDh_1)
) | (
    {31}!
    {32}in(c, MDh12': bitstring);
    {34}get MD_h_check(=MDh12') in
    {33}event SUCCESS
)

-- Query not event(SUCCESS) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not event(SUCCESS)
RESULT not event(SUCCESS) is true.

--------------------------------------------------------------
Verification summary:

Query not event(SUCCESS) is true.

--------------------------------------------------------------

