Linear part: No equation.
Convergent part:
con(divhead(mt),divrest(mt)) = mt
Completing equations...
Completed equations:
con(divhead(mt),divrest(mt)) = mt
Process 0 (that is, the initial process):
(
    {1}out(s, (iv,m,4))
) | (
    {2}!
    {3}in(s, (ha: bitstring,rm: bitstring,bl: nat));
    {4}if (bl ≠ 1) then
    (
        {5}let newbl: bitstring = divhead(rm) in
        {6}let newstream: bitstring = divrest(rm) in
        {7}let newha: bitstring = comp(ha,newbl) in
        {8}out(s, (newha,newstream,bl - 1))
    )
    else
        {9}let MDh: bitstring = comp(ha,rm) in
        {10}out(c, MDh)
) | (
    {11}!
    {12}in(c, mm: bitstring);
    (
        {13}out(t, (iv,mm,4,mm))
    ) | (
        {14}!
        {15}in(t, (ha_1: bitstring,rm_1: bitstring,bl_1: nat,mm_1: bitstring));
        {16}if (mm_1 = mm) then
        {17}if (bl_1 ≠ 1) then
        (
            {18}let newbl_1: bitstring = divhead(rm_1) in
            {19}let newstream_1: bitstring = divrest(rm_1) in
            {20}let newha_1: bitstring = comp(ha_1,newbl_1) in
            {21}out(t, (newha_1,newstream_1,bl_1 - 1,mm_1))
        )
        else
            {22}let MDh_1: bitstring = comp(ha_1,rm_1) in
            {23}insert MD(mm_1,MDh_1);
            {24}out(c, MDh_1)
    )
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}out(s, (iv,m,4))
) | (
    {2}!
    {3}in(s, (ha: bitstring,rm: bitstring,bl: nat));
    {4}if (bl ≠ 1) then
    (
        {5}let newbl: bitstring = divhead(rm) in
        {7}let newha: bitstring = comp(ha,newbl) in
        {6}let newstream: bitstring = divrest(rm) in
        {8}out(s, (newha,newstream,bl - 1))
    )
    else
        {9}let MDh: bitstring = comp(ha,rm) in
        {10}out(c, MDh)
) | (
    {11}!
    {12}in(c, mm: bitstring);
    (
        {13}out(t, (iv,mm,4,mm))
    ) | (
        {14}!
        {15}in(t, (ha_1: bitstring,rm_1: bitstring,bl_1: nat,mm_1: bitstring));
        {16}if (mm_1 = mm) then
        {17}if (bl_1 ≠ 1) then
        (
            {18}let newbl_1: bitstring = divhead(rm_1) in
            {20}let newha_1: bitstring = comp(ha_1,newbl_1) in
            {19}let newstream_1: bitstring = divrest(rm_1) in
            {21}out(t, (newha_1,newstream_1,bl_1 - 1,mm_1))
        )
        else
            {22}let MDh_1: bitstring = comp(ha_1,rm_1) in
            {23}insert MD(mm_1,MDh_1);
            {24}out(c, MDh_1)
    )
)

-- Query not attacker(m[]) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not attacker(m[])
RESULT not attacker(m[]) is true.

--------------------------------------------------------------
Verification summary:

Query not attacker(m[]) is true.

--------------------------------------------------------------

