Process 0 (that is, the initial process):
{1}let a1: nat = 4 in
(
    {2}!
    {3}out(u1, a1)
) | (
    {4}!
    {5}let s: bitstring = seed in
    {6}in(u1, x3: nat);
    {7}let x4: nat = x3 - 1 in
    {8}if (x4 ≠ 0) then
    (
        {9}out(u1, x4);
        {10}in(u2, (x5: nat,sk: bitstring));
        {11}if (x5 = x4) then
        {12}let otp4: bitstring = hash(sk) in
        {13}out(u2, (x3,otp4));
        {14}if (otp4 = hash(hash(hash(hash(seed))))) then
        {15}event COL
    )
    else
        {16}out(u2, (x3,hash(seed)))
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {2}!
    {1}let a1: nat = 4 in
    {3}out(u1, a1)
) | (
    {4}!
    {6}in(u1, x3: nat);
    {7}let x4: nat = x3 - 1 in
    {8}if (x4 ≠ 0) then
    (
        {9}out(u1, x4);
        {10}in(u2, (x5: nat,sk: bitstring));
        {11}if (x5 = x4) then
        {12}let otp4: bitstring = hash(sk) in
        {13}out(u2, (x3,otp4));
        {14}if (otp4 = hash(hash(hash(hash(seed))))) then
        {15}event COL
    )
    else
        {16}out(u2, (x3,hash(seed)))
)

-- Query not event(COL) in process 1.
Translating the process into Horn clauses...
Completing...
Starting query not event(COL)
goal reachable: event(COL)

Derivation:

1. The message 4 may be sent on channel u1[] at output {3}.
mess(u1[],4).

2. The message 4 may be sent on channel u1[] at output {3}.
mess(u1[],4).

3. The message 4 that may be sent on channel u1[] by 2 may be received at input {6}.
We have 3 ≠ 0.
So the message 3 may be sent on channel u1[] at output {9}.
mess(u1[],3).

4. The message 4 may be sent on channel u1[] at output {3}.
mess(u1[],4).

5. The message 4 that may be sent on channel u1[] by 4 may be received at input {6}.
We have 3 ≠ 0.
So the message 3 may be sent on channel u1[] at output {9}.
mess(u1[],3).

6. The message 3 that may be sent on channel u1[] by 5 may be received at input {6}.
We have 2 ≠ 0.
So the message 2 may be sent on channel u1[] at output {9}.
mess(u1[],2).

7. The message 4 may be sent on channel u1[] at output {3}.
mess(u1[],4).

8. The message 4 that may be sent on channel u1[] by 7 may be received at input {6}.
We have 3 ≠ 0.
So the message 3 may be sent on channel u1[] at output {9}.
mess(u1[],3).

9. The message 3 that may be sent on channel u1[] by 8 may be received at input {6}.
We have 2 ≠ 0.
So the message 2 may be sent on channel u1[] at output {9}.
mess(u1[],2).

10. The message 2 that may be sent on channel u1[] by 9 may be received at input {6}.
We have 1 ≠ 0.
So the message 1 may be sent on channel u1[] at output {9}.
mess(u1[],1).

11. The message 1 that may be sent on channel u1[] by 10 may be received at input {6}.
So the message (1,hash(seed[])) may be sent on channel u2[] at output {16}.
mess(u2[],(1,hash(seed[]))).

12. The message 2 that may be sent on channel u1[] by 6 may be received at input {6}.
The message (1,hash(seed[])) that may be sent on channel u2[] by 11 may be received at input {10}.
We have 1 ≠ 0.
So the message (2,hash(hash(seed[]))) may be sent on channel u2[] at output {13}.
mess(u2[],(2,hash(hash(seed[])))).

13. The message 3 that may be sent on channel u1[] by 3 may be received at input {6}.
The message (2,hash(hash(seed[]))) that may be sent on channel u2[] by 12 may be received at input {10}.
We have 2 ≠ 0.
So the message (3,hash(hash(hash(seed[])))) may be sent on channel u2[] at output {13}.
mess(u2[],(3,hash(hash(hash(seed[]))))).

14. The message 4 that may be sent on channel u1[] by 1 may be received at input {6}.
The message (3,hash(hash(hash(seed[])))) that may be sent on channel u2[] by 13 may be received at input {10}.
We have 3 ≠ 0.
So event COL may be executed at {15}.
event(COL).

15. By 14, event(COL).
The goal is reached, represented in the following fact:
event(COL).


A more detailed output of the traces is available with
  set traceDisplay = long.

out(u1, 4) at {3} in copy a received at {6} in copy a_1

out(u1, 3) at {9} in copy a_1 received at {6} in copy a_2

out(u1, 2) at {9} in copy a_2 received at {6} in copy a_3

out(u1, 1) at {9} in copy a_3 received at {6} in copy a_4

out(u1, 4) at {3} in copy a_5 received at {6} in copy a_6

out(u1, 3) at {9} in copy a_6 received at {6} in copy a_7

out(u1, 2) at {9} in copy a_7 received at {6} in copy a_8

out(u1, 4) at {3} in copy a_9 received at {6} in copy a_10

out(u1, 1) at {9} in copy a_8 received at {6} in copy a_11

out(u2, (1,hash(seed))) at {16} in copy a_4 received at {10} in copy a_8

out(u2, (2,hash(hash(seed)))) at {13} in copy a_8 received at {10} in copy a_2

out(u2, (3,hash(hash(hash(seed))))) at {13} in copy a_2 received at {10} in copy a_1

out(u2, (4,hash(hash(hash(hash(seed)))))) at {13} in copy a_1 received at {10} in copy a_3

event COL at {15} in copy a_1 (goal)

The event COL is executed at {15} in copy a_1.
A trace has been found.
RESULT not event(COL) is false.

--------------------------------------------------------------
Verification summary:

Query not event(COL) is false.

--------------------------------------------------------------

