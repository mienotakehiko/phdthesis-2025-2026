Linear part: No equation.
Convergent part:
con(divhead(mt),divrest(mt)) = mt
o2b(b2o(xb)) = xb
b2o(o2b(xo)) = xo
Ocon(Odivhead(mt),Odivrest(mt)) = mt
Odivhead(Ocon(lmt,rmt)) = lmt
Odivrest(Ocon(lmt,rmt)) = rmt
con4octs(x,y,z,w) = o2b(Ocon(x,Ocon(y,Ocon(z,w))))
oct1(x) = Odivhead(b2o(x))
oct2i2(x) = Odivrest(b2o(x))
oct2i34(x) = Odivhead(Odivrest(b2o(x)))
oct3i3(x) = Odivrest(Odivrest(b2o(x)))
oct3i4(x) = Odivhead(Odivrest(Odivrest(b2o(x))))
oct4(x) = Odivrest(Odivrest(Odivrest(b2o(x))))
Completing equations...
Completed equations:
oct4(o2b(Ocon(lmt,Ocon(lmt_1,Ocon(lmt_2,rmt))))) = rmt
oct3i4(o2b(Ocon(lmt,Ocon(lmt_1,Ocon(lmt_2,rmt))))) = lmt_2
con4octs(Odivhead(b2o(xb)),Odivhead(Odivrest(b2o(xb))),Odivhead(Odivrest(Odivrest(b2o(xb)))),Odivrest(Odivrest(Odivrest(b2o(xb))))) = xb
oct4(o2b(Ocon(lmt,Ocon(lmt_1,rmt)))) = Odivrest(rmt)
oct3i4(o2b(Ocon(lmt,Ocon(lmt_1,rmt)))) = Odivhead(rmt)
oct3i3(o2b(Ocon(lmt,Ocon(lmt_1,rmt)))) = rmt
oct2i34(o2b(Ocon(lmt,Ocon(lmt_1,rmt)))) = lmt_1
con4octs(Odivhead(mt),Odivhead(Odivrest(mt)),Odivhead(Odivrest(Odivrest(mt))),Odivrest(Odivrest(Odivrest(mt)))) = o2b(mt)
oct4(o2b(Ocon(lmt,rmt))) = Odivrest(Odivrest(rmt))
oct3i4(o2b(Ocon(lmt,rmt))) = Odivhead(Odivrest(rmt))
oct3i3(o2b(Ocon(lmt,rmt))) = Odivrest(rmt)
oct2i34(o2b(Ocon(lmt,rmt))) = Odivhead(rmt)
oct2i2(o2b(Ocon(lmt,rmt))) = rmt
oct1(o2b(Ocon(lmt,rmt))) = lmt
con4octs(x,Odivhead(mt),Odivhead(Odivrest(mt)),Odivrest(Odivrest(mt))) = o2b(Ocon(x,mt))
oct4(o2b(xo)) = Odivrest(Odivrest(Odivrest(xo)))
oct3i4(o2b(xo)) = Odivhead(Odivrest(Odivrest(xo)))
oct3i3(o2b(xo)) = Odivrest(Odivrest(xo))
oct2i34(o2b(xo)) = Odivhead(Odivrest(xo))
oct2i2(o2b(xo)) = Odivrest(xo)
oct1(o2b(xo)) = Odivhead(xo)
con4octs(x,y,Odivhead(mt),Odivrest(mt)) = o2b(Ocon(x,Ocon(y,mt)))
oct4(x) = Odivrest(Odivrest(Odivrest(b2o(x))))
oct3i4(x) = Odivhead(Odivrest(Odivrest(b2o(x))))
oct3i3(x) = Odivrest(Odivrest(b2o(x)))
oct2i34(x) = Odivhead(Odivrest(b2o(x)))
oct2i2(x) = Odivrest(b2o(x))
oct1(x) = Odivhead(b2o(x))
con4octs(x,y,z,w) = o2b(Ocon(x,Ocon(y,Ocon(z,w))))
Odivrest(Ocon(lmt,rmt)) = rmt
Odivhead(Ocon(lmt,rmt)) = lmt
Ocon(Odivhead(mt),Odivrest(mt)) = mt
b2o(o2b(xo)) = xo
o2b(b2o(xb)) = xb
con(divhead(mt),divrest(mt)) = mt
Process 0 (that is, the initial process):
(
    {1}new m1: bitstring;
    {2}new m2: bitstring;
    {3}out(c, (m2,2));
    {4}out(t, (iv,m1,2,length(m1),m1));
    {11}get MD_h_len(=m1,MDh1': bitstring) in
    {5}out(c, MDh1');
    {6}out(s, (iv,m1,2,m1));
    {10}get MD_h(=m1,MDh1: bitstring) in
    {7}out(u, (MDh1,m2,2,length(con(m1,m2)),con(m1,m2)));
    {9}get MD_h_pad(=con(m1,m2),MDh12: bitstring) in
    {8}insert MD_h_check(MDh12)
) | (
    {12}!
    {13}in(s, (ha: bitstring,rm: bitstring,bl: nat,mm: bitstring));
    {14}if (bl ≠ 1) then
    (
        {15}let newbl: bitstring = divhead(rm) in
        {16}let newstream: bitstring = divrest(rm) in
        {17}let newha: bitstring = comp(ha,newbl) in
        {18}out(s, (newha,newstream,bl - 1,mm))
    )
    else
        {19}let MDh: bitstring = comp(ha,rm) in
        {20}insert MD_h(mm,MDh)
) | (
    {21}!
    {22}in(t, (ha_1: bitstring,rm_1: bitstring,bl_1: nat,len: bitstring,mm_1: bitstring));
    {23}if (bl_1 ≠ 1) then
    (
        {24}let newbl_1: bitstring = divhead(rm_1) in
        {25}let newstream_1: bitstring = divrest(rm_1) in
        {26}let newha_1: bitstring = comp(ha_1,newbl_1) in
        {27}out(t, (newha_1,newstream_1,bl_1 - 1,len,mm_1))
    )
    else
        {28}let newha_2: bitstring = comp(ha_1,rm_1) in
        {29}let MDh_1: bitstring = comp(newha_2,len) in
        {30}insert MD_h_len(mm_1,MDh_1)
) | (
    {31}!
    {32}in(u, (ha_2: bitstring,rm_2: bitstring,bl_2: nat,len_1: bitstring,mm_2: bitstring));
    {33}if (bl_2 ≠ 1) then
    (
        {34}let newbl_2: bitstring = divhead(rm_2) in
        {35}let newstream_2: bitstring = divrest(rm_2) in
        {36}let newha_3: bitstring = comp(ha_2,newbl_2) in
        {37}out(u, (newha_3,newstream_2,bl_2 - 1,len_1,mm_2))
    )
    else
        {38}let p: bitstring = con4octs(b2o(rm_2),zero,zero,zero) in
        {39}let newha_4: bitstring = comp(ha_2,p) in
        {40}let MDh_2: bitstring = comp(newha_4,len_1) in
        {41}insert MD_h_pad(mm_2,MDh_2)
) | (
    {42}!
    {43}in(c, MDh12': bitstring);
    {45}get MD_h_check(=MDh12') in
    {44}event SUCCESS
)

--  Process 1 (that is, process 0, with let moved downwards):
(
    {1}new m1: bitstring;
    {2}new m2: bitstring;
    {3}out(c, (m2,2));
    {4}out(t, (iv,m1,2,length(m1),m1));
    {11}get MD_h_len(=m1,MDh1': bitstring) in
    {5}out(c, MDh1');
    {6}out(s, (iv,m1,2,m1));
    {10}get MD_h(=m1,MDh1: bitstring) in
    {7}out(u, (MDh1,m2,2,length(con(m1,m2)),con(m1,m2)));
    {9}get MD_h_pad(=con(m1,m2),MDh12: bitstring) in
    {8}insert MD_h_check(MDh12)
) | (
    {12}!
    {13}in(s, (ha: bitstring,rm: bitstring,bl: nat,mm: bitstring));
    {14}if (bl ≠ 1) then
    (
        {15}let newbl: bitstring = divhead(rm) in
        {17}let newha: bitstring = comp(ha,newbl) in
        {16}let newstream: bitstring = divrest(rm) in
        {18}out(s, (newha,newstream,bl - 1,mm))
    )
    else
        {19}let MDh: bitstring = comp(ha,rm) in
        {20}insert MD_h(mm,MDh)
) | (
    {21}!
    {22}in(t, (ha_1: bitstring,rm_1: bitstring,bl_1: nat,len: bitstring,mm_1: bitstring));
    {23}if (bl_1 ≠ 1) then
    (
        {24}let newbl_1: bitstring = divhead(rm_1) in
        {26}let newha_1: bitstring = comp(ha_1,newbl_1) in
        {25}let newstream_1: bitstring = divrest(rm_1) in
        {27}out(t, (newha_1,newstream_1,bl_1 - 1,len,mm_1))
    )
    else
        {28}let newha_2: bitstring = comp(ha_1,rm_1) in
        {29}let MDh_1: bitstring = comp(newha_2,len) in
        {30}insert MD_h_len(mm_1,MDh_1)
) | (
    {31}!
    {32}in(u, (ha_2: bitstring,rm_2: bitstring,bl_2: nat,len_1: bitstring,mm_2: bitstring));
    {33}if (bl_2 ≠ 1) then
    (
        {34}let newbl_2: bitstring = divhead(rm_2) in
        {36}let newha_3: bitstring = comp(ha_2,newbl_2) in
        {35}let newstream_2: bitstring = divrest(rm_2) in
        {37}out(u, (newha_3,newstream_2,bl_2 - 1,len_1,mm_2))
    )
    else
        {38}let p: bitstring = con4octs(b2o(rm_2),zero,zero,zero) in
        {39}let newha_4: bitstring = comp(ha_2,p) in
        {40}let MDh_2: bitstring = comp(newha_4,len_1) in
        {41}insert MD_h_pad(mm_2,MDh_2)
) | (
    {42}!
    {43}in(c, MDh12': bitstring);
    {45}get MD_h_check(=MDh12') in
    {44}event SUCCESS
)

-- Query not event(SUCCESS) in process 1.
Translating the process into Horn clauses...
Completing...
200 rules inserted. Base: 140 rules (50 with conclusion selected). Queue: 2 rules.
Starting query not event(SUCCESS)
RESULT not event(SUCCESS) is true.

--------------------------------------------------------------
Verification summary:

Query not event(SUCCESS) is true.

--------------------------------------------------------------

