theory indcpa_AEAD_mac_then_enc_rogaway_scheme_TAMF04 begin

// Function signature and definition of the equational theory E

functions: dec/3, enc/3, fst/1, getMessage/1, left/1, mac/2, pair/2,
           pk/1, revealSign/2, revealVerify/3, right/1, sign/2, snd/1, true/0,
           verify/3, verifyMac/3
equations:
    dec(k2, enc(m, k2, n), n) = m,
    fst(<x.1, x.2>) = x.1,
    getMessage(revealSign(x.1, x.2)) = x.1,
    left(<x.1, x.2>) = x.1,
    revealVerify(revealSign(x.1, x.2), x.1, pk(x.2)) = true,
    right(<x.1, x.2>) = x.2,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true,
    verifyMac(mac(m, k1), m, k1) = true







rule (modulo E) Setup:
   [ Fr( ~k1 ), Fr( ~k2 ), Fr( ~key ) ]
  --[ OnlyOnce( ), Setup( ~k1, ~k2, ~key ) ]->
   [ !Key( ~k1 ), !Key( ~k2 ), !Skey( $A, ~key ) ]

rule (modulo E) attackerkey:
   [ !Skey( $A, key ) ] --[ Oracle( $A ) ]-> [ Out( key ) ]

rule (modulo E) Attacker_make_message:
   [ Fr( m_ ) ] --> [ Out( <$A, m_> ), St_Oracle( m_ ) ]

rule (modulo E) Oracle_sign:
   [ In( <$A, m_> ), Fr( ~key ), St_Oracle( m_ ) ]
  --[ Oracle( $A ), Sender( $B ), Role( 'Oracle' ) ]->
   [ Out( sign(<$A, m_>, ~key) ), St_ReceiveKeyOraclesign( m_, ~key ) ]

rule (modulo E) Alice_makemac_then_enc:
   [
   Fr( ~m ), Fr( ~key ), !Key( ~k1 ), !Key( ~k2 ), Fr( ~nonce ), Fr( ~data )
   ]
  --[
  Sendmac( ~k1, mac(<~m, ~nonce, ~data>, ~k1), ~nonce, ~data ),
  Secret_A( ~m ), Oracle( $A ), Signed( $A, ~m )
  ]->
   [
   Out( <enc(<~m, mac(<~m, ~nonce, ~data>, ~k1)>, ~k2, ~nonce), ~nonce, 
         ~data, mac(<~m, ~nonce, ~data>, ~k1)>
   ),
   St_ReceiveKey( ~m, ~key )
   ]

rule (modulo E) Encrypt_oracle:
   [
   Fr( ~m ), Fr( r ), !Key( ~k2 ), In( alicetag ), Fr( ~nonce ),
   Fr( ~data ), Fr( r )
   ]
  -->
   [ Out( <enc(<~m, alicetag>, ~k2, ~nonce), ~nonce, ~data, alicetag> ) ]

rule (modulo E) Bob_verifymac_decrypt:
   [
   St_ReceiveKeyOraclesign( m_, key_ ), In( <c, ~nonce, ~data, alicetag> ),
   St_ReceiveKey( ~m, key ), !Key( ~k1 ), !Key( ~k2 ),
   In( sign(<$B, ~m>, ~k2) )
   ]
  --[
  Eq( verifyMac(alicetag, left(dec(~k2, c, ~nonce)), ~k1), true ),
  Authentic( ~k1, right(dec(~k2, c, ~nonce)), ~nonce, ~data ),
  Notequalvalue( <revealSign(<$A, m_>, ~k1), sign(<$B, ~m>, ~k2)> ),
  Secret_B( left(dec(~k2, c, ~nonce)) ), Verified( $A, $B, ~m )
  ]->
   [ ]

restriction unique [right]:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction unique [left]:
  "∀ #i #j. ((OnlyOnce( ) @ #i) ∧ (OnlyOnce( ) @ #j)) ⇒ (#i = #j)"
  // safety formula

restriction Equality [right]:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Equality [left]:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

lemma message_secret_alice [right]:
  all-traces "∀ m #i #j. ((Secret_A( m ) @ #i) ∧ (K( m ) @ #j)) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ m #i #j. (Secret_A( m ) @ #i) ∧ (K( m ) @ #j)"
*/
by sorry

lemma message_secret_alice [left]:
  all-traces "∀ m #i #j. ((Secret_A( m ) @ #i) ∧ (K( m ) @ #j)) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ m #i #j. (Secret_A( m ) @ #i) ∧ (K( m ) @ #j)"
*/
by sorry

lemma message_secret_bob [right]:
  all-traces "∀ m #i #j. ((Secret_B( m ) @ #i) ∧ (K( m ) @ #j)) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ m #i #j. (Secret_B( m ) @ #i) ∧ (K( m ) @ #j)"
*/
by sorry

lemma message_secret_bob [left]:
  all-traces "∀ m #i #j. ((Secret_B( m ) @ #i) ∧ (K( m ) @ #j)) ⇒ (⊥)"
/*
guarded formula characterizing all counter-examples:
"∃ m #i #j. (Secret_B( m ) @ #i) ∧ (K( m ) @ #j)"
*/
by sorry

lemma message_authentication [right]:
  all-traces
  "∀ k t n d #i.
    (Authentic( k, t, n, d ) @ #i) ⇒
    (∃ #j. (Sendmac( k, t, n, d ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ k t n d #i.
  (Authentic( k, t, n, d ) @ #i)
 ∧
  ∀ #j. (Sendmac( k, t, n, d ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma message_authentication [left]:
  all-traces
  "∀ k t n d #i.
    (Authentic( k, t, n, d ) @ #i) ⇒
    (∃ #j. (Sendmac( k, t, n, d ) @ #j) ∧ (#j < #i))"
/*
guarded formula characterizing all counter-examples:
"∃ k t n d #i.
  (Authentic( k, t, n, d ) @ #i)
 ∧
  ∀ #j. (Sendmac( k, t, n, d ) @ #j) ⇒ ¬(#j < #i)"
*/
by sorry

lemma ow_value_notequal [right]:
  all-traces
  "∀ #i #j x.
    ((Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j x.
  (Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j) ∧ ¬(#i = #j)"
*/
by sorry

lemma ow_value_notequal [left]:
  all-traces
  "∀ #i #j x.
    ((Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j)) ⇒ (#i = #j)"
/*
guarded formula characterizing all counter-examples:
"∃ #i #j x.
  (Notequalvalue( x ) @ #i) ∧ (Notequalvalue( x ) @ #j) ∧ ¬(#i = #j)"
*/
by sorry

lemma existential_unforgeability [right]:
  all-traces
  "∀ X Y m #i.
    (Verified( X, Y, m ) @ #i) ⇒
    ((∃ #j. (Signed( X, m ) @ #j) ∧ (#j < #i)) ∨
     (∃ #l. (Oracle( X ) @ #l) ∧ (#l < #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ X Y m #i.
  (Verified( X, Y, m ) @ #i)
 ∧
  (∀ #j. (Signed( X, m ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #l. (Oracle( X ) @ #l) ⇒ ¬(#l < #i))"
*/
by sorry

lemma existential_unforgeability [left]:
  all-traces
  "∀ X Y m #i.
    (Verified( X, Y, m ) @ #i) ⇒
    ((∃ #j. (Signed( X, m ) @ #j) ∧ (#j < #i)) ∨
     (∃ #l. (Oracle( X ) @ #l) ∧ (#l < #i)))"
/*
guarded formula characterizing all counter-examples:
"∃ X Y m #i.
  (Verified( X, Y, m ) @ #i)
 ∧
  (∀ #j. (Signed( X, m ) @ #j) ⇒ ¬(#j < #i)) ∧
  (∀ #l. (Oracle( X ) @ #l) ⇒ ¬(#l < #i))"
*/
by sorry

diffLemma Observational_equivalence:
by sorry

/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.10.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2024-10-30 14:56:23.355649243 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: code4-F.spthy

  processing time: 1.31s
  
  RHS :  message_secret_alice (all-traces): analysis incomplete (1 steps)
  LHS :  message_secret_alice (all-traces): analysis incomplete (1 steps)
  RHS :  message_secret_bob (all-traces): analysis incomplete (1 steps)
  LHS :  message_secret_bob (all-traces): analysis incomplete (1 steps)
  RHS :  message_authentication (all-traces): analysis incomplete (1 steps)
  LHS :  message_authentication (all-traces): analysis incomplete (1 steps)
  RHS :  ow_value_notequal (all-traces): analysis incomplete (1 steps)
  LHS :  ow_value_notequal (all-traces): analysis incomplete (1 steps)
  RHS :  existential_unforgeability (all-traces): analysis incomplete (1 steps)
  LHS :  existential_unforgeability (all-traces): analysis incomplete (1 steps)
  DiffLemma:  Observational_equivalence : analysis incomplete (1 steps)

==============================================================================
